> {-# LANGUAGE RecursiveDo #-}
> module Growing where
> import Reflex
> import Reflex.Dom
> import Control.Monad
> import Data.Map
> import Data.Functor.Misc -- For Const2
> import Multiple

So far so good, but what we really want to be able to do is have a variable
number of "children" in container widget like this. Let's start by making a
widget with a button to grow the value by adding extra Simple values and widgets

> growingWidget :: MonadWidget t m => m (Dynamic t Multiple)
> growingWidget = do
>   growButton <- liftM ((++[One]) <$) $ button "Add"
>   values <- foldDyn ($) [] growButton -- m (Dynamic t Multiple)
>   let builder xs = forM xs simpleWidget >>= sequenceDyn -- m [Dynamic t Simple] >>= m (Dynamic t Multiple)
>   widgets <- widgetHold (builder []) $ fmap (builder) (updated values) -- m (Dynamic (Dynamic t Multiple))
>   return $ joinDyn widgets
>
> sequenceDyn :: MonadWidget t m => [Dynamic t a] -> m (Dynamic t [a])
> sequenceDyn = foldM (combineDyn (\ys y -> ys ++ [y])) (constDyn [])
>
> main = mainWidget $ growingWidget' >>= display

There is a problem with the code above, which may not be obvious until you go to
test it (it's not flagged at compile time). 'values' is generated by folding in
changes triggered by the Add button. This means that any changes to the values
that come from within each simpleWidget will be discarded/forgotten any time the
Add button is pressed (although they will appear in the Dynamic result of the
function until that time). Ok, let's take another stab at it, folding in any
updates that come out of the widgets as well:

> growingWidget' :: MonadWidget t m => m (Dynamic t Multiple)
> growingWidget' = mdo
>   growButton <- liftM ((++[One]) <$) $ button "Add"
>   values <- foldDyn ($) [] $ leftmost [growButton,updates]
>   let builder xs = forM xs simpleWidget >>= sequenceDyn
>   widgets <- widgetHold (builder []) $ fmap (builder) (updated values)
>   let widgets' = joinDyn widgets
>   let updates = fmap (const) $ updated widgets'       -- m (Event t Multiple -> Multiple)
>   display values
>   return widgets'

The code above compiles but doesn't work at runtime - when you press the Add
button things get "unstable", flickering back and forth between different states
and being generally unresponsive. We think it is because we are making an
infinite cycle of pushing update events that came from the widgets back in to
the widgets. Hmmm... back to the drawing board. This function looks promising:

listWithKeyShallowDiff :: (Ord k, MonadWidget t m) =>
  Map k v ->
  Event t (Map k (Maybe v)) ->
  (k -> v -> Event t v -> m a) ->
  m (Dynamic t (Map k a))

> growingWidget'' :: MonadWidget t m => m (Dynamic t Multiple)
> growingWidget'' = el "div" $ do
>   let initialMap = empty :: Map Int Simple
>   addbutton <- button "Add"
>   countDyn <- count addButton -- :: MonadWidget t m => m (Dynamic t Int)
>   let countEvent = tagDyn constDyn addButton
>   let growEvent = fmap (\k -> singleton k (Just One)) countEvent
>   let builder key iValue event = simpleWidget initialValue
>   widgets <- listWithKeyShallowDiff initialMap growEvent (builder)
>   -- so widgets :: Dynamic t (Map k (Dynamic t Simple))
>   let values = joinDynThroughMap widgets -- Dynamic (Map k Simple)
>   values' <- forDyn values elems -- m (Dynamic t [Simple])
>   display values'
>   return values'

That's working nicely now!
